# Kogge_stone_adder
Kogge-Stone Adder는 병렬 prefix 계산을 통해 carry를 빠르게 계산하는 구조

##Level 1(P1, G1) 
입력신호 𝐴𝑖, 𝐵𝑖를 사용해서 Propagate(P)와 Generate(G)를 구한다. 
<img width="178" height="62" alt="image" src="https://github.com/user-attachments/assets/ae6996f7-ed5c-4bc5-ab0f-ebbdb9ed23ef" />

P𝑖는 Carry를 전달할 수 있는가를 나타내고 𝐺𝑖는 Carry를 생성하는가를 의미한다. 

##Level 2(P2, G2)
<img width="304" height="60" alt="image" src="https://github.com/user-attachments/assets/4b1eee1f-10b2-4cc8-81b9-f90e775813d1" />

이때 이론적인 Prefix 계산규칙으로는 𝑃2[𝑛]값은 𝑛≥1 범위부터 계산이 가능하다. 
P2[0] = 𝑃[0]⋅ 𝑃[−1] 이때 𝑃[−1]값이 존재하지 않기 때문이다. 
G2[0] = BITOR(G[0],(P[0] ⋅ Cin))으로 계산한다. 

##Level 3(P3, G3) 
<img width="300" height="61" alt="image" src="https://github.com/user-attachments/assets/b0fe5e9b-0966-4e1b-8b1a-5d58e0845b6a" />

이때 이론적인 Prefix 계산규칙으로는 𝑃3[𝑛]값은 𝑛≥ 2 범위부터 계산이 가능하다. 
P3[1] = 𝑃2[1]⋅𝑃2[−1]  이때 𝑃2[−1] 값 이 존재하지 않기 때문이다. 하지만 하드웨어 최적
화를 위해서 𝑛≥ 3범위부터 연산을 수행한다. (실제로 사용하는 값은 𝑃3[3]이후 값들이다) 
G3[0] 은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺2[0] 을 그대로 전달한다. 
G3[1]값은 𝐺3[1] = 𝐵𝐼𝑇𝑂𝑅(𝐺3[1],(𝑃3[1]⋅𝐶𝑖𝑛))식을 사용하여 구한다. 

##Level 4(P4, G4) 
<img width="284" height="57" alt="image" src="https://github.com/user-attachments/assets/3347c084-c037-4be0-ade4-62d7651c0d76" />

이때 이론적인 Prefix 계산규칙으로는 𝑃4[𝑛]값은 𝑛≥ 4 범위부터 계산이 가능하다. 
P4[3] = 𝑃3[3]⋅𝑃3[−1]  이때 𝑃3[−1] 값 이 존재하지 않기 때문이다. 하지만 하드웨어 최적
화를 위해서 𝑛≥ 7범위부터 연산을 수행한다. 
G4[0]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺2[0]을 그대로 전달한다. 
G4[1]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺3[1]을 그대로 전달한다. 
G4[2]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺3[2]을 그대로 전달한다. 
G4[3]값은 𝐺4[3] = 𝐵𝐼𝑇𝑂𝑅(𝐺4[3],(𝑃4[3]⋅𝐶𝑖𝑛))식을 사용하여 구한다.

##Level 5(P5, G5) 
<img width="313" height="63" alt="image" src="https://github.com/user-attachments/assets/89355e34-8ef4-452b-b386-8ea03db5765d" />

이때 이론적인 Prefix 계산규칙으로는 𝑃5[𝑛]값은 𝑛≥ 8 범위부터 계산이 가능하다. 
P5[8] = 𝑃5[8]⋅𝑃5[−1]  이때 𝑃4[−1] 값 이 존재하지 않기 때문이다. 하지만 하드웨어 최적
화를 위해서 𝑛≥ 15범위부터 연산을 수행한다. 
G5[0]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺2[0]을 그대로 전달한다. 
G5[1]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺3[1]을 그대로 전달한다. 
G5[2]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺3[2]을 그대로 전달한다. 
G5[3]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺4[3]을 그대로 전달한다. 
G5[4]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺4[4]을 그대로 전달한다. 
G5[5]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺4[5]을 그대로 전달한다. 
G5[6]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺4[6]을 그대로 전달한다. 
G5[7]값은 𝐺5[7] = 𝐵𝐼𝑇𝑂𝑅(𝐺5[7],(𝑃5[7]⋅𝐶𝑖𝑛))식을 사용하여 구한다.

##Level 6(P6, G6) 
<img width="304" height="59" alt="image" src="https://github.com/user-attachments/assets/9d532b10-8256-4cc8-aa03-2d441817badd" />

이때 이론적인 Prefix 계산규칙으로는 𝑃6[𝑛]값은 𝑛≥ 16 범위부터 계산이 가능하다. 
P5[16] = 𝑃5[16]⋅ 𝑃5[−1]  이때 𝑃5[−1] 값 이 존재하지 않기 때문이다. 하지만 하드웨어 최
적화를 위해서 𝑛≥ 31범위부터 연산을 수행한다. 
G6[0]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺2[0]을 그대로 전달한다. 
G6[1]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺3[1]을 그대로 전달한다. 
G6[2]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺3[2]을 그대로 전달한다. 
G6[3]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺4[3]을 그대로 전달한다. 
G6[4]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺4[4]을 그대로 전달한다. 
G6[5]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺4[5]을 그대로 전달한다. 
G6[6]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺4[6]을 그대로 전달한다. 
G6[7]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺5[7]을 그대로 전달한다. 
G6[8]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺5[8]을 그대로 전달한다. 
G6[9]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺5[9]을 그대로 전달한다. 
G6[10]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺5[10]을 그대로 전달한다. 
G6[11]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺5[11]을 그대로 전달한다. 
G6[12]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺5[12]을 그대로 전달한다. 
G6[13]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺5[13]을 그대로 전달한다. 
G6[14]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺5[14]을 그대로 전달한다. 
G6[15]값은 𝐺6[15] = 𝐵𝐼𝑇𝑂𝑅(𝐺6[15],(𝑃6[15]⋅𝐶𝑖𝑛))식을 사용하여 구한다. 

##Level 7(P7, G7) 
<img width="303" height="55" alt="image" src="https://github.com/user-attachments/assets/ef6f3c4b-2768-41b6-831c-f4b9f61d1bfc" />

이때 이론적인 Prefix 계산규칙으로는 𝑃7[𝑛]값은 𝑛≥ 32 범위부터 계산이 가능하다. 
P7[16] = 𝑃7[16]⋅ 𝑃7[−1]  이때 𝑃7[−1] 값 이 존재하지 않기 때문이다. 하지만 하드웨어 최
적화를 위해서 𝑛≥ 63범위부터 연산을 수행한다. 
G7[0]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺2[0]을 그대로 전달한다. 
G7[1]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺3[1]을 그대로 전달한다. 
G7[2]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺3[2]을 그대로 전달한다. 
G7[3]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺4[3]을 그대로 전달한다. 
G7[4]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺4[4]을 그대로 전달한다. 
G7[5]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺4[5]을 그대로 전달한다. 
G7[6]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺4[6]을 그대로 전달한다. 
G7[7]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺5[7]을 그대로 전달한다. 
G7[8]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺5[8]을 그대로 전달한다. 
G7[9]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺5[9]을 그대로 전달한다. 
G7[10]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺5[10]을 그대로 전달한다. 
G7[11]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺5[11]을 그대로 전달한다. 
G7[12]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺5[12]을 그대로 전달한다. 
G7[13]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺5[13]을 그대로 전달한다. 
G7[14]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺5[14]을 그대로 전달한다. 
G7[15]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺6[15]을 그대로 전달한다. 
G7[16]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺6[16]을 그대로 전달한다. 
G7[17]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺6[17]을 그대로 전달한다. 
G7[18]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺6[18]을 그대로 전달한다. 
G7[19]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺6[19]을 그대로 전달한다. 
G7[20]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺6[20]을 그대로 전달한다. 
G7[21]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺6[21]을 그대로 전달한다. 
G7[22]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺6[22]을 그대로 전달한다. 
G7[23]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺6[23]을 그대로 전달한다. 
G7[24]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺6[24]을 그대로 전달한다. 
G7[25]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺6[25]을 그대로 전달한다. 
G7[26]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺6[26]을 그대로 전달한다. 
G7[27]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺6[27]을 그대로 전달한다. 
G7[28]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺6[28]을 그대로 전달한다. 
G7[29]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺6[29]을 그대로 전달한다. 
G7[30]은 계산이 불가능 하기에 해당 위치의 이전 레벨 값인 𝐺6[30]을 그대로 전달한다. 
G7[31]값은 𝐺7[31] = 𝐵𝐼𝑇𝑂𝑅(𝐺7[31],(𝑃7[31]⋅𝐶𝑖𝑛))식을 사용하여 구한다.

##Sum 구하기 
<img width="232" height="33" alt="image" src="https://github.com/user-attachments/assets/85f95e65-78fa-4e5e-b275-b5603fd0cc93" />
